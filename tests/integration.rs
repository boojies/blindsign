// Regular imported crates
extern crate blindsign;
extern crate curve25519_dalek;
extern crate rand;
extern crate sha3;

#[cfg(test)]
mod integration_test {
    use sha3::Sha3_512;

    use blindsign::{
        keypair::BlindKeypair,
        request::BlindRequest,
        session::BlindSession,
        signature::{UnblindedSigData, WiredUnblindedSigData},
        Error, Result,
    };

    #[test]
    fn session_with_random_msg() {
        // Generates a new keypair. The private key is used for creating blind
        // signatures on the blinded message, and the public key is used for
        // authenticating the unblinded signature on the unblinded message.
        let keypair = BlindKeypair::generate().unwrap();

        // Initiates a new blind session (bs) on the signer side, the first step of
        // which is generating of the value R' (rp).
        let (rp, bs) = BlindSession::new().unwrap();

        // Initiates a new blind request on the requester side, which is input R' and
        // generates e' (ep).
        let (ep, br) = BlindRequest::new::<Sha3_512>(&rp).unwrap();

        // Signs the e' value, which is essentially the blinded message hash. Produces
        // S' (sp), which is the blind signature.
        let sp = bs.sign_ep(&ep, keypair.private()).unwrap();

        // Forms a new blindly signed message object on the requester side, when
        // provided with the blind signature previously generated by the signer
        // side.
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();

        // A demonstration of converting the blindly signed message between
        // internal representation and wired format for transmission over the
        // network.
        let wired = WiredUnblindedSigData::from(unblinded_signed_msg);
        let sig = wired.to_internal_format().unwrap();

        // A demonstration of authenticating the blind signature
        assert!(sig.authenticate(keypair.public()));
    }

    #[test]
    fn session_with_specific_msg() {
        // Generates a new keypair. The private key is used for creating blind
        // signatures on the blinded message, and the public key is used for
        // authenticating the unblinded signature on the unblinded message.
        let keypair = BlindKeypair::generate().unwrap();

        // Initiates a new blind session (bs) on the signer side, the first step of
        // which is generating of the value R' (rp).
        let (rp, bs) = BlindSession::new().unwrap();

        // Initiates a new blind request on the requester side, which is input R' and
        // generates e' (ep). In this case, using a specific message.
        let (ep, br) = BlindRequest::new_specific_msg::<Sha3_512, &str>(&rp, "specific").unwrap();

        // Signs the e' value, which is essentially the blinded message hash. Produces
        // S' (sp), which is the blind signature.
        let sp = bs.sign_ep(&ep, keypair.private()).unwrap();

        // Forms a new blindly signed message object on the requester side, when
        // provided with the blind signature previously generated by the signer
        // side.
        let unblinded_signed_msg = br.gen_signed_msg(&sp).unwrap();

        // A demonstration of converting the blindly signed message between
        // internal representation and wired format for transmission over the
        // network.
        let wired = WiredUnblindedSigData::from(unblinded_signed_msg);
        let sig = wired.to_internal_format().unwrap();

        // A demonstration of authenticating the blind signature
        assert!(sig.authenticate(keypair.public()));
    }
}
